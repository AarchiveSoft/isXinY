import os.path
import sys

import pandas as pd
from PyQt6.QtCore import Qt
from PyQt6.QtGui import QIcon
from PyQt6.QtWidgets import (QApplication, QGridLayout, QFileDialog, QLabel, QComboBox, QLineEdit,
                             QPushButton, QFrame, QMessageBox, QWidget)
from openpyxl.styles import PatternFill


def get_path():
    """
    Returns the path to the icon file named "compare_4222.ico".

    If the current script is running from a frozen executable (such as a standalone executable generated by
    PyInstaller), the function will retrieve the icon path using `sys._MEIPASS`, which is a special attribute present
    in frozen executables.

    If the script is running from a regular Python environment, the function will retrieve the icon path using
    `os.path.dirname(__file__)`, which provides the path of the current script.

    Returns:
        str: The absolute path to the "compare_4222.ico" file.

    """
    return (
        os.path.join(sys._MEIPASS, "compare_4222.ico")
        if getattr(sys, 'frozen', False)
        else os.path.join(os.path.dirname(__file__), "compare_4222.ico")
    )


class Gui(QWidget):
    """

    The `Gui` class is a subclass of QWidget. It represents a graphical user interface for the application.

    Attributes:
    - `title`: The title of the GUI window (default: 'Ist X in Y?')
    - `window_height`: The height of the GUI window (default: 900)
    - `window_width`: The width of the GUI window (default: 450)
    - `icon_path`: The path to the icon file (default: "")

    Methods:
    - `__init__()`: Initializes the object and sets the initial values for the attributes.
    - `initUi()`: Initializes the user interface.
    - `select_file(type)`: Selects a file using a file dialog and sets the corresponding file paths based on the
    provided type parameter.
    - `select_out_path()`: Selects the output path by opening a directory dialog and setting the selected directory
    as the output path.
    - `confirm()`: Executes the Compare.execute method with the specified parameters.

    """

    def __init__(self):
        """
        Initializes the object and sets the initial values for the following attributes:

        :param self: The object instance.
        :type self: object

        :return: None
        :rtype: None

        :Example:

        >>> app = MyApp()
        >>> app.__init__()

        """
        super().__init__()
        self.title = 'Ist X in Y?'
        self.window_height = 900
        self.window_width = 450
        self.icon = get_path()

        self.initUi()

    def initUi(self):
        """
        Initialize the user interface.

        :return: None
        """
        self.setWindowTitle(self.title)
        self.setWindowIcon(QIcon(self.icon))
        self.layout = QGridLayout()

        self.inTitleLabel = QLabel("<b>INPUT</b>")
        self.inTitleLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(self.inTitleLabel, 0, 0, 1, -1)

        self.isColLabel = QLabel("Sind EAN's von Spalte: ")
        self.layout.addWidget(self.isColLabel, 1, 0)
        self.isColumnSel = QComboBox()
        for column in ['A', 'B', 'C', 'D', 'E', 'F']:
            self.isColumnSel.addItem(column)
        self.layout.addWidget(self.isColumnSel, 1, 1)
        self.isPathLabel = QLabel("der Liste: ")
        self.layout.addWidget(self.isPathLabel, 2, 0)
        self.isPathInput = QLineEdit("")
        self.layout.addWidget(self.isPathInput, 3, 0)
        self.isPathButton = QPushButton("Durchsuchen...")
        self.isPathButton.clicked.connect(lambda: self.select_file(1))
        self.layout.addWidget(self.isPathButton, 3, 1)
        self.inColLabel = QLabel("Vorhanden in Spalte: ")
        self.layout.addWidget(self.inColLabel, 4, 0)
        self.inColumnSel = QComboBox()
        for column in ['A', 'B', 'C', 'D', 'E', 'F']:
            self.inColumnSel.addItem(column)
        self.layout.addWidget(self.inColumnSel, 4, 1)
        self.inPathLabel = QLabel("der Liste: ")
        self.layout.addWidget(self.inPathLabel, 5, 0)
        self.inPathInput = QLineEdit("")
        self.layout.addWidget(self.inPathInput, 6, 0)
        self.inPathButton = QPushButton("Durchsuchen...")
        self.inPathButton.clicked.connect(lambda: self.select_file(2))
        self.layout.addWidget(self.inPathButton, 6, 1)
        self.small_list_path = ""
        self.isListCol = self.isColumnSel.currentIndex()
        self.large_list_path = ""
        self.inListCol = self.inColumnSel.currentIndex()
        self.output_path = ""

        self.h_line1 = QFrame()
        self.h_line1.setFrameShape(QFrame.Shape.HLine)
        self.layout.addWidget(self.h_line1, 7, 0, 1, -1)

        self.outTitleLabel = QLabel("<b>OUTPUT</b>")
        self.outTitleLabel.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(self.outTitleLabel, 8, 0, 1, -1)

        self.outLabel = QLabel("Output speichern unter: ")
        self.layout.addWidget(self.outLabel, 9, 0)
        self.outPathInput = QLineEdit("", self)
        self.layout.addWidget(self.outPathInput, 10, 0)
        self.outButton = QPushButton("Durchsuchen...", self)
        self.outButton.clicked.connect(self.select_out_path)
        self.layout.addWidget(self.outButton, 10, 1)
        self.outNameLabel = QLabel("Output File Name: ")
        self.layout.addWidget(self.outNameLabel, 11, 0)
        self.outNameInput = QLineEdit("", self)
        self.outNameInput.textChanged.connect(self.update_outname)
        self.layout.addWidget(self.outNameInput, 12, 0, 1, -1)

        self.h_line2 = QFrame()
        self.h_line2.setFrameShape(QFrame.Shape.HLine)
        self.layout.addWidget(self.h_line2, 13, 0, 1, -1)

        self.warning_msg1 = QLabel("<b>ACHTUNG</b>")
        self.warning_msg1.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.warning_msg1.setStyleSheet(
            "border: 2px solid #ff0000;"
            "padding: 4px;"
        )
        self.warning_msg2 = QLabel("Excel Listen müssen vor <b>Bestätigen</b> geschlossen sein")
        self.warning_msg2.setAlignment(Qt.AlignmentFlag.AlignCenter)
        self.layout.addWidget(self.warning_msg1, 14, 0, 1, -1)
        self.layout.addWidget(self.warning_msg2, 15, 0, 1, -1)

        self.confirm_button = QPushButton("Bestätigen")
        self.confirm_button.setStyleSheet(
            "font-weight: bold;"
            "padding: 4px"
        )
        self.confirm_button.clicked.connect(self.confirm)
        self.layout.addWidget(self.confirm_button, 16, 0, 1, -1)

        self.setLayout(self.layout)

    def select_file(self, type):
        """
        :param type: The type of file path to select. Should be either 1 or 2.
        :return: None

        Selects a file using a file dialog and sets the corresponding file paths based on the provided type parameter.

        Example usage:
            select_file(1)  # Select file for 'is' path
            select_file(2)  # Select file for 'in' path
        """
        file_dialog = QFileDialog()
        file_path, _ = QFileDialog.getOpenFileName(file_dialog, "Excel Datei wählen <b>(muss '.xlsx' sein, wenn nötig "
                                                                "erst konvertieren)</b>",
                                                   "", "Excel Files ("
                                                       "*.xlsx)")
        if file_path:
            original_file_name = os.path.basename(file_path)
            split_file_name = original_file_name.rsplit(".", 1)
            file_name = f'{split_file_name[0]}_status.{split_file_name[1]}'
            if type == 1:  # for 'is' path
                self.small_list_path = file_path
                self.isPathInput.setText(self.small_list_path)
                self.outNameInput.setText(file_name)
            elif type == 2:  # for 'in' path
                self.large_list_path = file_path
                self.inPathInput.setText(self.large_list_path)
            else:
                print("Something went wrong")

    def select_out_path(self):
        """
        Selects the output path by opening a directory dialog and setting the selected directory as the output path.

        :return: None
        """
        directory = QFileDialog.getExistingDirectory(self, "Speicherort wählen")
        if directory:
            self.output_path = directory
            self.outPathInput.setText(directory)
            self.outName = self.outNameInput.text()

    def confirm(self):
        """
        Executes the compare_tool method to perform a comparison between two lists.

        Parameters:
        - self (object): The current instance of the class.

        Returns:
        - None.
        """
        is_column_sel_index = self.isColumnSel.currentIndex()
        in_column_sel_index = self.inColumnSel.currentIndex()
        compare_tool = Compare()
        compare_tool.execute(self.small_list_path, is_column_sel_index, self.large_list_path, in_column_sel_index,
                             self.output_path, self.outName)

    def update_outname(self):
        self.outName = self.outNameInput.text()



class Compare:
    """
    Class to compare values between two Excel files.

    Attributes:
        None

    Methods:
        execute(small_list_path, small_list_col, large_list_path, large_list_col, output_path):
            Executes the comparison between two Excel files and saves the result to a new Excel file.
    """

    def execute(self, small_list_path, small_list_col, large_list_path, large_list_col, output_path, output_name):
        """
        Reads two Excel files, compares values from a small list to a large list, and saves the result to a new Excel
        file with conditional formatting.

        Parameters:
        - small_list_path : str
            The path of the Excel file containing the small list.
        - small_list_col : int
            The column index (starting from 0) of the value to check in the small list.
        - large_list_path : str
            The path of the Excel file containing the large list.
        - large_list_col : int
            The column index (starting from 0) of the value to check in the large list.
        - output_path : str
            The path of the directory where the output file will be saved.
        - output_name : str
            The name of the output file (including the extension).

        Raises:
        - Exception : If there is an error reading any of the input Excel files.

        Example usage:
        execute("path_to_small_list.xlsx", 0, "path_to_large_list.xlsx", 2, "output_directory", "output_file.xlsx")
        """

        output_path = os.path.normpath(output_path)
        output_with_name_path = os.path.join(output_path, output_name)

        # Function to read an Excel file and handle exceptions
        def read_excel_file(path):
            """
            Read an Excel file from the given path.

            :param path: The path of the Excel file to be read.
            :return: The pandas DataFrame containing the data read from the Excel file.
            :raises: Exception if there is an error reading the file.
            """
            try:
                df = pd.read_excel(path, engine='openpyxl')
                return df
            except Exception as e:
                print(f"Error reading {path}: {e}")
                raise

        # Read the Excel files
        small_df = read_excel_file(small_list_path)
        large_df = read_excel_file(large_list_path)

        # Print the first few rows to ensure data is read correctly
        print("Small list preview:")
        print(small_df.head())
        print("\nLarge list preview:")
        print(large_df.head())

        # Assume the value to check is in a specific column
        # Adjust the column index if necessary
        small_values = small_df.iloc[:, small_list_col]  # select column (EAN)
        large_values = large_df.iloc[:, large_list_col]  # select column (EAN)

        # Print the values to be compared
        print("\nValues from small list (first 5):")
        print(small_values.head())
        print("\nValues from large list (first 5):")
        print(large_values.head())

        # Create a new column 'status' to store the result of the check
        def check_value_in_large_list(value, large_values):
            """
            Check if a value exists in a large list.

            :param value: The value to check.
            :param large_values: The large list to search in.
            :type value: Any
            :type large_values: list
            :return: 'found' if the value is found, 'not found' otherwise.
            :rtype: str
            """
            return 'found' if value in large_values.values else 'not found'

        small_df['status'] = small_values.apply(lambda x: check_value_in_large_list(x, large_values))

        print('writer about to start')
        # Save the modified DataFrame back to an Excel file with conditional formatting
        writer = pd.ExcelWriter(output_with_name_path, engine='openpyxl')
        small_df.to_excel(writer, index=False)
        print(f'Writer setup for {output_with_name_path}')

        # Load the workbook and select the active sheet
        workbook = writer.book
        print(f'workbook: {workbook} - loaded')
        sheet = workbook.active
        print(f'sheet: {sheet} - loaded')

        # Define fill colors
        green_fill = PatternFill(start_color='00FF00', end_color='00FF00', fill_type='solid')
        red_fill = PatternFill(start_color='FF0000', end_color='FF0000', fill_type='solid')

        # Apply the fill colors based on the status
        for row in range(2, len(small_df) + 2):  # Start from the second row because the first row is the header
            status = sheet[f'E{row}'].value  # Assuming the 'status' column is the fifth column
            fill = green_fill if status == 'found' else red_fill
            for col in range(1, 6):  # Adjust the range if there are more columns to color
                sheet.cell(row=row, column=col).fill = fill

        # Save the workbook
        print(f'about to save workbook: {workbook}')
        workbook.save(output_with_name_path)
        print(f'workbook: {workbook} saved, about to close workbook: {workbook}')
        workbook.close()
        print(f'workbook: {workbook} - closed')

        # confirmation popup
        msg = QMessageBox()
        msg.setWindowTitle("Meisterleistung!")
        msg.setText(f'Liste {output_name} erfolgreich in \n{output_with_name_path} \nerstellt!')
        msg.setStandardButtons(QMessageBox.StandardButton.Ok)
        msg.setIcon(QMessageBox.Icon.Information)

        msg.exec()

        print("Script completed successfully.")


if __name__ == "__main__":
    app = QApplication(sys.argv)

    window = Gui()  # Your QWidget subclass
    window.show()

    sys.exit(app.exec())
